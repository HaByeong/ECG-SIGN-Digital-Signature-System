# ECG-SIGN 프로젝트 한눈에 보기

## 🎯 프로젝트 핵심
> **ECG(심전도) 파형을 개인 고유의 "디지털 서명"으로 변환하여 생체 인증에 활용**

### 왜 ECG를 선택했는가?
| 생체 인증 방식 | 장점 | 단점 |
|---------------|------|------|
| 지문 | 보편화, 빠름 | 복제 가능, 손상 시 인식 불가 |
| 얼굴 | 비접촉 | 사진/영상으로 우회 가능 |
| 홍채 | 정확도 높음 | 고가 장비 필요 |
| **ECG** | **살아있는 사람만 가능, 위조 불가** | 전극 부착 필요 |

**ECG의 핵심 장점**: 심장이 뛰어야만 신호가 나오므로 **생체 여부 자동 확인**

---

## 📊 시스템 전체 흐름

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              전체 데이터 흐름                                 │
└─────────────────────────────────────────────────────────────────────────────┘

  [피부 전극]        [하드웨어]              [모바일]              [서버]
      │                  │                     │                    │
      ▼                  ▼                     ▼                    ▼
  ┌───────┐      ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
  │ 심장  │──▶│ AD8232 센서  │──▶│ Android 앱   │──▶│ Python 서버  │
  │ 전기  │  │ + Arduino    │  │              │  │              │
  │ 신호  │  │ + HC-06 BT   │  │ 실시간 그래프 │  │ ECG 파이프라인│
  └───────┘      └──────────────┘      └──────────────┘      └──────────────┘
                       │                     │                    │
                  500Hz 샘플링          Bluetooth SPP          TCP/IP
                  정수 문자열            + TCP Socket          JSON 응답
```

### 통신 규격 상세
| 구간 | 프로토콜 | 데이터 형식 | 예시 |
|------|----------|-------------|------|
| Arduino → 앱 | Bluetooth SPP | 정수 + 줄바꿈 | `512\n`, `498\n` |
| 앱 → 서버 | TCP Socket | 정수 또는 명령어 | `512`, `CMD:REGISTER:user1` |
| 서버 → 앱 | TCP Socket | JSON | `{"status":"success","similarity":0.92}` |

---

## 🔧 사용 기술 상세

### 하드웨어 구성
| 구성 요소 | 모델/기술 | 역할 | 주요 사양 |
|-----------|----------|------|----------|
| **ECG 센서** | AD8232 | 심장 전기 신호 증폭 | 단일 리드, 내장 필터 |
| **MCU** | Arduino UNO | ADC 변환 + 데이터 전송 | 10비트 ADC (0~1023) |
| **Bluetooth** | HC-06 | 무선 시리얼 통신 | 9600bps, SPP 프로토콜 |
| **전극** | 3-리드 | 심전도 측정 | RA, LA, RL 배치 |

### 소프트웨어 구성
| 플랫폼 | 언어/프레임워크 | 주요 라이브러리 | 역할 |
|--------|----------------|----------------|------|
| **Android** | Java | MPAndroidChart, Bluetooth API | UI, 통신, 시각화 |
| **Server** | Python 3 | NumPy, SciPy | 신호 처리, 인증 |

### 왜 이 기술들을 선택했는가?
- **AD8232**: 저가(약 1만원)이면서 계측 증폭기 내장, 학습용으로 적합
- **Arduino**: 간단한 ADC 구현, 풍부한 레퍼런스
- **HC-06**: SPP 지원으로 Android Bluetooth Classic과 호환
- **Python**: NumPy/SciPy로 신호 처리 알고리즘 빠르게 구현

---

## 🔬 ECG 처리 파이프라인 상세

```
원본 ECG 신호 (3000샘플, 6초, 500Hz)
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  1️⃣ 전처리 (Preprocessing)                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ High-pass   │→│ Low-pass    │→│ Notch       │          │
│  │ 0.5Hz       │  │ 45Hz        │  │ 60Hz        │          │
│  │ 베이스라인   │  │ 고주파 노이즈│  │ 전원 노이즈  │          │
│  │ 제거        │  │ 제거        │  │ 제거        │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│  → Butterworth 필터 (양방향, 위상 지연 없음)                  │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  2️⃣ R-peak 검출 (Pan-Tompkins Algorithm)                    │
│                                                              │
│  밴드패스 → 미분 → 제곱 → 이동평균 → 적응형 임계값 → R-peak   │
│  (5-15Hz)  (기울기) (양수화) (150ms)   (동적 조정)            │
│                                                              │
│  → 1985년 IEEE 발표, 실시간 QRS 검출 표준 알고리즘            │
│  → 생리학적 제약: RR 간격 200ms~2000ms (30~300 BPM)           │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  3️⃣ 비트 처리 (Beat Processing)                             │
│                                                              │
│  R-peak 기준 분할 → Z-score 정규화 → 리샘플링 → 이상치 제거   │
│  (앞 250ms,        (평균=0,         (300샘플    (MAD 기반)    │
│   뒤 400ms)         표준편차=1)      고정)                    │
│                                                              │
│  → 여러 심박의 가중 평균으로 "대표 템플릿" 생성               │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  4️⃣ 특징 추출 (Feature Extraction) - 30개 이상              │
│                                                              │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐         │
│  │ 형태학적(16) │ │ HRV(8)       │ │ 주파수(12)   │         │
│  │ R,Q,S,P,T    │ │ SDNN,RMSSD   │ │ LF,MF,HF     │         │
│  │ 진폭,간격    │ │ pNN50,CV     │ │ 파워,스펙트럼│         │
│  └──────────────┘ └──────────────┘ └──────────────┘         │
│          │               │               │                   │
│          └───────────────┴───────────────┘                   │
│                          │                                   │
│  ┌──────────────┐        │                                   │
│  │ 통계적(8)    │────────┘                                   │
│  │ 왜도,첨도    │                                            │
│  │ 엔트로피,RMS │                                            │
│  └──────────────┘                                            │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  5️⃣ 서명 생성 (Signature Generation)                        │
│                                                              │
│  특징 벡터 → 가중치 적용 → Min-Max 정규화 → 8비트 이산화     │
│  [37개]     (형태:1.5,    (0~1 범위)      (0~255 정수)       │
│              HRV:1.0,                                        │
│              주파수:0.8,                     │               │
│              통계:0.7)                       ▼               │
│                                        SHA-256 해시          │
│                                        (64자 16진수)         │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
    디지털 서명 완성!
```

---

## 🔑 핵심 알고리즘 상세

### 1. 전처리 필터 (Butterworth Filter)

#### 기본 구성
| 필터 종류 | 차단 주파수 | 차수 | 목적 | 제거 대상 |
|-----------|-------------|------|------|-----------|
| High-pass | 0.5 Hz | 2차 | 저주파 제거 | 호흡, 움직임으로 인한 베이스라인 흔들림 |
| Low-pass | 45 Hz | 4차 | 고주파 제거 | 근전도(EMG), 전자기 간섭 |
| Notch | 60 Hz | Q=30 | 특정 주파수 제거 | 전원선 노이즈 (한국 60Hz) |

#### 수학적 배경: Butterworth 필터란?

```
Butterworth 필터의 진폭 응답 (크기 응답):

              1
|H(jω)|² = ─────────────
           1 + (ω/ωc)^2n

여기서:
- ω: 각주파수 (2πf)
- ωc: 차단 각주파수 (2πfc)
- n: 필터 차수
```

**왜 Butterworth인가?**
```
필터 비교:
┌────────────┬─────────────────────────┬─────────────────────────┐
│ 필터 종류   │ 통과대역 특성            │ 천이대역 특성            │
├────────────┼─────────────────────────┼─────────────────────────┤
│ Butterworth│ 최대 평탄 (ripple 없음)  │ 느린 roll-off           │
│ Chebyshev  │ ripple 있음              │ 빠른 roll-off           │
│ Bessel     │ 평탄                     │ 매우 느린 roll-off       │
└────────────┴─────────────────────────┴─────────────────────────┘

ECG 선택 이유: 파형 왜곡 최소화가 핵심!
→ 통과대역에서 ripple(물결)이 생기면 QRS 형태 왜곡
→ Butterworth의 "최대 평탄" 특성이 ECG에 적합
```

#### 필터 설계 과정 (실제 코드 기반)

```python
# 1. 정규화된 차단 주파수 계산
#    나이퀴스트 주파수 = 샘플링 주파수 / 2 = 250Hz
normalized_cutoff = cutoff_freq / nyquist_freq
                  = 0.5Hz / 250Hz = 0.002

# 2. Butterworth 필터 계수 설계
#    b, a = signal.butter(차수, 정규화_주파수, 필터_타입)
b, a = signal.butter(2, 0.002, btype='high')

# 3. 양방향 필터링 (Zero-phase filtering)
filtered = signal.filtfilt(b, a, ecg_signal)
```

#### 양방향 필터링 (`filtfilt`)의 중요성

```
일반 필터링 (filter):        양방향 필터링 (filtfilt):
        
원본:    ∿∿∿               원본:    ∿∿∿
        ↓                          ↓
결과:     ∿∿∿              결과:   ∿∿∿
      (지연 발생!)               (지연 없음!)
      
위상 지연이 발생하면:
- R-peak 위치가 틀어짐
- P-QRS-T 간격 측정 오류
- 특징 추출 정확도 저하

filtfilt 동작 원리:
1) 순방향 필터링 → 결과1 (지연 +d)
2) 결과1을 뒤집기
3) 순방향 필터링 → 결과2 (지연 +d)
4) 결과2를 다시 뒤집기 → 최종 (지연 상쇄!)
```

#### Notch 필터의 Q 팩터

```
Q 팩터 = 중심주파수 / 대역폭

Q=30, 중심주파수=60Hz일 때:
대역폭 = 60/30 = 2Hz
→ 59Hz ~ 61Hz 영역만 제거

Q가 높으면: 좁은 대역 제거 (정밀, ECG 손상 적음)
Q가 낮으면: 넓은 대역 제거 (노이즈 완벽 제거, ECG 손상 가능)

Q=30 선택 이유:
- 60Hz 전원 노이즈만 정확히 타겟팅
- ECG 주요 성분(QRS: 5-15Hz) 보존
```

---

### 2. Pan-Tompkins 알고리즘 (1985)

> 📚 **논문**: Pan, J., & Tompkins, W. J. (1985). "A Real-Time QRS Detection Algorithm"
> IEEE Transactions on Biomedical Engineering

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 밴드패스 │ → │  미분   │ → │  제곱   │ → │이동평균 │ → │피크검출 │
│ 5-15Hz  │    │ 5점필터 │    │  x²    │    │ 150ms  │    │적응임계│
└─────────┘    └─────────┘    └─────────┘    └─────────┘    └─────────┘
     │              │              │              │              │
  QRS 강조      기울기 강조     양수화+증폭    덩어리화      R-peak 위치
```

#### 단계별 상세 수학

##### 1️⃣ 밴드패스 필터 (5-15Hz)
```
목적: QRS 복합체만 통과, P파와 T파 제거

주파수 성분별 분석:
┌─────────────┬────────────┬───────────────┐
│ ECG 성분     │ 주파수 대역 │ 밴드패스 통과  │
├─────────────┼────────────┼───────────────┤
│ 베이스라인   │ 0-0.5 Hz   │ ✗ 제거        │
│ P파, T파    │ 0.5-5 Hz   │ ✗ 제거        │
│ QRS 복합체  │ 5-15 Hz    │ ✓ 통과        │
│ 근전도 노이즈│ >15 Hz     │ ✗ 제거        │
└─────────────┴────────────┴───────────────┘

결과: QRS만 남은 깨끗한 신호
```

##### 2️⃣ 5점 미분 필터
```
목적: 급격한 신호 변화(기울기) 강조

미분 필터 전달함수:
H(z) = (1/8T)(-z⁻² - 2z⁻¹ + 2z¹ + z²)

필터 계수: [1, 2, 0, -2, -1] × (fs/8)

시간 영역 해석:
y[n] = (fs/8) × (x[n+2] + 2x[n+1] - 2x[n-1] - x[n-2])

왜 5점인가?
- 3점 미분: 노이즈에 민감
- 5점 미분: 노이즈 감소 + 정확한 기울기 추정
- 7점 미분: 계산량 증가, 시간 지연

실제 효과:
원본:    ▁▂▃▄▅▆▇█▇▆▅▄▃▂▁  (R파)
미분:    ▁▂▄▆█▇▄▁▁▄▇█▆▄▂▁  (상승/하강 구간 강조)
```

##### 3️⃣ 제곱 연산
```
목적: 
1) 모든 값을 양수로 변환
2) 큰 값을 더 크게 (비선형 증폭)
3) R파 강조, 작은 노이즈 억제

수식: y[n] = x[n]²

효과:
입력:  [-5, -3, 0, 3, 5]
출력:  [25,  9, 0, 9, 25]

R파의 기울기가 크므로 → 미분 후 값 큼 → 제곱 후 매우 큼
노이즈 기울기가 작으므로 → 미분 후 값 작음 → 제곱 후 무시 가능
```

##### 4️⃣ 이동 평균 (Moving Window Integration)
```
목적: QRS 복합체를 하나의 봉우리로 합침

윈도우 크기: 150ms (500Hz에서 75 샘플)

수식:
y[n] = (1/N) × Σ x[n-i]  (i = 0 to N-1)

왜 150ms인가?
- QRS 복합체 지속시간: 80-120ms
- 150ms로 QRS 전체를 덮음
- 너무 짧으면: QRS가 여러 피크로 분리
- 너무 길면: 인접 QRS가 합쳐짐

시각화:
제곱 후:  ▁▂▅▇█▇▅▁▁▁▁▁▂▅▇█▇▅▁
이동평균: ▁▂▃▅▇█▇▅▃▂▁▁▂▃▅▇█▇▅▃▂▁
         (부드러운 하나의 봉우리)
```

##### 5️⃣ 적응형 임계값 (Adaptive Thresholding)
```
핵심: 신호 세기에 따라 임계값을 동적으로 조정

초기 임계값:
threshold = mean(signal) + 0.5 × std(signal)

적응 로직 (실제 구현):
1. 로컬 최대값 찾기 (maximum_filter1d)
2. 임계값 이상인 피크만 후보로 선정
3. 피크가 없으면 임계값 낮춤 (mean까지)

RR 간격 제약:
- 최소 RR: 200ms (300 BPM) → 빈맥 고려
- 최대 RR: 2000ms (30 BPM) → 서맥 고려

의사 코드:
if (candidate - last_peak) >= min_rr_interval:
    accept(candidate)
else:
    reject(candidate)  # 너무 빠른 연속 피크 제거
```

#### R-peak 위치 정제 (Refinement)

```
문제: 이동평균으로 인해 피크 위치가 약간 지연됨

해결: 원본 신호에서 정확한 위치 재탐색

알고리즘:
1. 적분 신호에서 대략적 R-peak 위치 획득: peak_approx
2. 원본 신호에서 ±50ms 윈도우 탐색
3. 해당 윈도우 내 최대값 위치 = 정확한 R-peak

search_window = 50ms = 25 샘플 (500Hz)
refined_peak = argmax(original[peak-25 : peak+25])
```

### 3. 특징 추출 상세

#### 왜 특징 추출이 필요한가?

```
문제: 원본 ECG 신호로 직접 비교하면?
- 6초 신호 = 3000 샘플 = 3000차원 벡터
- 차원이 너무 높음 → "차원의 저주" (Curse of Dimensionality)
- 노이즈, 측정 시점 차이에 민감
- 저장 공간 비효율

해결: 의미 있는 특징만 추출
- 37개 특징 = 37차원 벡터
- 3000 → 37 = 약 80배 차원 축소
- 핵심 패턴만 남김 → 노이즈에 강건
```

#### P-QRS-T 파형 경계 탐지 알고리즘

```
ECG 파형 구조:
      
         R
         ▲
        /│\
       / │ \
  P   /  │  \    T
 ∧   /   │   \  ∧
/  \Q────┘────S/  \
────────────────────
   │PR│QRS│ ST │QT │
   
탐지 순서:
1. R-peak 먼저 찾기 (가장 뚜렷함)
2. R 기준 왼쪽 탐색 → Q (최소값)
3. R 기준 오른쪽 탐색 → S (최소값)
4. Q 왼쪽 영역에서 P파 찾기
5. S 오른쪽 영역에서 T파 찾기
```

```python
# 실제 경계 탐지 코드 로직
# Q onset: R-peak 이전 100ms 구간에서 최소값
q_search = template[r_idx - 50 : r_idx]  # 100ms = 50샘플
q_onset = argmin(q_search)

# S end: R-peak 이후 100ms 구간에서 최소값  
s_search = template[r_idx : r_idx + 50]
s_end = argmin(s_search)

# P파: Q 이전 150ms 구간에서 최대값
p_region = template[q_onset - 75 : q_onset]
p_peak = argmax(p_region)

# T파: S 이후 400ms 구간에서 최대값
t_region = template[s_end + 10 : s_end + 200]
t_peak = argmax(t_region)
```

#### 형태학적 특징 (Morphological) - 16개

| 특징 | 설명 | 개인차 원인 | 수식/계산 |
|------|------|-------------|-----------|
| R 진폭 | R파의 높이 | 심장 크기, 전극 위치 | `template[r_idx]` |
| Q 진폭 | Q파의 깊이 | 심실 중격 탈분극 | `template[q_idx]` |
| S 진폭 | S파의 깊이 | 심실 탈분극 방향 | `template[s_idx]` |
| P 진폭 | P파의 높이 | 심방 크기 | `template[p_peak]` |
| T 진폭 | T파의 높이 | 심실 재분극 | `template[t_peak]` |
| QRS 지속시간 | Q~S 시간 (ms) | 심실 전도 속도 | `(s_idx - q_idx) / fs × 1000` |
| PR 간격 | P~R 시간 | 방실 전도 시간 | `(r_idx - p_onset) / fs × 1000` |
| QT 간격 | Q~T 시간 | 전체 심실 활동 시간 | `(t_offset - q_idx) / fs × 1000` |
| P/R 비율 | P파/R파 비 | 심방/심실 상대 크기 | `p_amp / r_amp` |
| T/R 비율 | T파/R파 비 | 재분극 특성 | `t_amp / r_amp` |
| R 상승기울기 | R파 상승 속도 | 탈분극 속도 | `(R - Q) / (r_idx - q_idx)` |
| R 하강기울기 | R파 하강 속도 | 탈분극 패턴 | `(S - R) / (s_idx - r_idx)` |
| QRS 면적 | QRS 아래 면적 | 심실 활동량 | `trapz(\|template[q:s]\|)` |
| P 면적 | P파 아래 면적 | 심방 활동량 | `trapz(\|template[p_on:p_off]\|)` |
| T 면적 | T파 아래 면적 | 재분극 활동량 | `trapz(\|template[t_on:t_off]\|)` |

```
면적 계산 (사다리꼴 적분):
       ▲ amplitude
       │   ●────●
       │  /      \
       │ /        \
       │●          ●
       └─────────────▶ time
       
trapz() = Σ (y[i] + y[i+1]) × Δt / 2
```

#### HRV 특징 (Heart Rate Variability) - 8개

> HRV: 심박 간격의 변동성. 자율신경계 상태 반영

```
RR 간격 시퀀스 예시:
R-peak 위치: [0, 450, 920, 1350, 1820, 2250, ...]
RR 간격 (샘플): [450, 470, 430, 470, 430, ...]
RR 간격 (ms): [900, 940, 860, 940, 860, ...]
```

| 특징 | 수식 | 의미 | 생리학적 해석 |
|------|------|------|---------------|
| Mean RR | `μ = Σ RRi / N` | 평균 RR 간격 | 기본 심박수 |
| Std RR | `σ = √(Σ(RRi-μ)²/N)` | RR 표준편차 | 전체 변동성 |
| SDNN | = Std RR | 표준편차 | 자율신경계 전체 활동 |
| RMSSD | `√(Σ(RRi+1-RRi)²/(N-1))` | 연속 차이의 RMS | **부교감신경** 활동 |
| pNN50 | `(ΔRR>50ms 개수)/N × 100` | 50ms 이상 차이 비율 | 미주신경 톤 |
| pNN20 | `(ΔRR>20ms 개수)/N × 100` | 20ms 이상 차이 비율 | 단기 변동성 |
| CV | `σ / μ` | 변동계수 | 정규화된 변동성 |
| Mean HR | `60000 / Mean_RR` | 평균 심박수 (BPM) | 심박 속도 |

```
RMSSD 계산 예시:
RR: [900, 940, 860, 940, 860] ms
ΔRR: [40, -80, 80, -80] ms
ΔRR²: [1600, 6400, 6400, 6400]
평균: 5200
RMSSD: √5200 ≈ 72.1 ms

해석: RMSSD가 높으면 부교감신경 활성화 상태
     (이완, 휴식 상태를 의미)
```

#### 주파수 특징 (Frequency Domain) - 12개

> FFT (Fast Fourier Transform)를 사용해 시간 영역 → 주파수 영역 변환

```
푸리에 변환의 의미:
시간 영역:  ∿∿∿∿∿∿∿ (복잡한 파형)
           ↓ FFT
주파수 영역: 어떤 주파수가 얼마나 있는가?

         파워
         │ █
         │ █ █
         │ █ █ █
         │ █ █ █ █
         └─────────▶ 주파수
          LF  MF  HF
```

| 특징 | 주파수 대역 | 의미 | 수식 |
|------|-------------|------|------|
| LF Power | 0-5 Hz | P파, T파 에너지 | `Σ|FFT|²(0-5Hz) / total` |
| MF Power | 5-15 Hz | QRS 에너지 | `Σ|FFT|²(5-15Hz) / total` |
| HF Power | 15-40 Hz | 고주파 성분 | `Σ|FFT|²(15-40Hz) / total` |
| LF/HF Ratio | - | 저/고주파 비율 | `LF_Power / HF_Power` |
| Spectral Centroid | - | 주파수 무게중심 | `Σ(f × P(f)) / Σ P(f)` |
| Spectral Spread | - | 주파수 분산 | `√(Σ(f-centroid)² × P(f) / Σ P(f))` |
| Dominant Freq | - | 최대 파워 주파수 | `argmax(|FFT|²)` |
| Top 5 FFT | - | 상위 5개 FFT 계수 | 정렬 후 상위 5개 |

```
Spectral Centroid (스펙트럼 중심) 직관:
- 무게중심처럼 "평균적인 주파수"
- 밝은(고주파 많은) 소리 → centroid 높음
- 어두운(저주파 많은) 소리 → centroid 낮음

ECG에서:
- QRS가 뚜렷하면 → MF 대역 파워 높음 → centroid ≈ 10Hz
- 노이즈가 많으면 → HF 대역 파워 높음 → centroid ↑
```

#### 통계적 특징 (Statistical) - 8개

| 특징 | 수식 | 의미 | ECG에서의 해석 |
|------|------|------|----------------|
| Mean | `μ = Σx / N` | 평균값 | 베이스라인 레벨 |
| Std | `σ = √(Σ(x-μ)²/N)` | 표준편차 | 진폭 변동 크기 |
| Skewness | `E[(x-μ)³] / σ³` | 왜도 | 파형 비대칭성 |
| Kurtosis | `E[(x-μ)⁴] / σ⁴ - 3` | 첨도 | R파 뾰족함 정도 |
| Energy | `Σ x²` | 에너지 | 신호 세기 |
| RMS | `√(Σx² / N)` | 제곱평균제곱근 | 실효값 |
| ZCR | `Σ\|sign(x[n]) - sign(x[n-1])\| / 2N` | 제로 크로싱 비율 | 주파수 관련 |
| Entropy | `-Σ p(x) log₂ p(x)` | 엔트로피 | 신호 복잡도 |

```
왜도(Skewness)와 첨도(Kurtosis) 시각화:

왜도 = 0 (대칭):    왜도 > 0 (오른쪽 꼬리):    왜도 < 0 (왼쪽 꼬리):
      ▲                    ▲                      ▲
     /│\                  /│\                    /│\
    / │ \                / │  \                 /  │ \
   /  │  \              /  │   \_              _/   │  \
  /   │   \            /   │     \_          _/     │   \
 
첨도 = 0 (정규분포):  첨도 > 0 (뾰족):         첨도 < 0 (평평):
      ▲                   ▲                      ▲▲▲
     /│\                  │                     /   \
    / │ \                /│\                   /     \
   /  │  \              / │ \                 /       \
  /   │   \           _/  │  \_              /         \

ECG에서 R파가 뾰족하면 → 첨도 높음 (개인 특성)
```

```
엔트로피 직관:
- 낮은 엔트로피: 예측 가능, 단순한 패턴
  예: ▁▁▁▁▁▁▁▁▁▁ (일정한 신호)
  
- 높은 엔트로피: 예측 어려움, 복잡한 패턴
  예: ▁▃▅▂▇▄▁▆▃▅ (불규칙한 신호)

계산 방법 (히스토그램 기반):
1. 신호를 50개 구간(bin)으로 나눔
2. 각 구간의 확률 p(x) 계산
3. -Σ p(x) log₂ p(x) 계산
```

### 4. 정규화 과정 (3단계)

> 정규화는 **왜 필요한가?**
> - 측정 환경 차이 (전극 접촉 상태, 피부 저항)
> - 시간에 따른 변화 (운동 후, 휴식 시)
> - 서로 다른 스케일의 특징 통합

```
┌─────────────────────────────────────────────────────────────┐
│                    정규화 흐름도                             │
└─────────────────────────────────────────────────────────────┘

1️⃣ 비트 처리 단계: Z-score 정규화
   ┌─────────────────────────────────────┐
   │  normalized = (x - mean) / std      │
   │  → 평균=0, 표준편차=1                │
   │  → 목적: 진폭 차이 제거, 형태만 비교 │
   └─────────────────────────────────────┘
                    │
                    ▼
2️⃣ 서명 생성 단계: Min-Max 정규화
   ┌─────────────────────────────────────┐
   │  normalized = (x - min) / (max-min) │
   │  → 범위: 0 ~ 1                      │
   │  → 목적: 이산화 전 일정 범위로 변환  │
   └─────────────────────────────────────┘
                    │
                    ▼
3️⃣ 인증 비교 단계: Z-score 정규화
   ┌─────────────────────────────────────┐
   │  v1_norm = (v1 - mean(v1)) / std(v1)│
   │  v2_norm = (v2 - mean(v2)) / std(v2)│
   │  → 목적: 측정 시점 간 스케일 차이 제거│
   └─────────────────────────────────────┘
```

#### Z-score vs Min-Max 비교

```
┌────────────────┬──────────────────────────┬──────────────────────────┐
│                │ Z-score                   │ Min-Max                   │
├────────────────┼──────────────────────────┼──────────────────────────┤
│ 수식           │ (x - μ) / σ              │ (x - min) / (max - min)   │
│ 결과 범위      │ 보통 -3 ~ +3 (이론상 무한)│ 0 ~ 1 (고정)              │
│ 이상치 영향    │ 적음 (평균/표준편차 사용) │ 큼 (최소/최대 사용)        │
│ 사용 시점      │ 패턴 비교, 형태 분석      │ 이산화, 해시 생성 전       │
│ 해석           │ "평균에서 몇 σ 떨어졌나?" │ "전체 범위의 몇 %인가?"    │
└────────────────┴──────────────────────────┴──────────────────────────┘
```

#### 왜 단계별로 다른 정규화?

```
1️⃣ 비트 처리 (Z-score):
   목적: 각 비트의 "형태"만 비교
   
   같은 사람, 다른 시점 측정:
   측정1: 진폭 100  →  Z-score 후 → 같은 패턴
   측정2: 진폭 150  →  Z-score 후 → 같은 패턴 ✓
   
   전극 접촉 차이로 진폭이 달라도 형태가 같으면 OK

2️⃣ 서명 생성 (Min-Max):
   목적: 8비트 이산화를 위한 준비
   
   이산화: round(normalized × 255)
   
   Z-score 결과가 -2.5 ~ +2.5라면?
   → 음수 처리 곤란, 범위 불명확
   
   Min-Max 결과는 0 ~ 1
   → × 255 = 0 ~ 255 깔끔하게 정수화

3️⃣ 인증 비교 (Z-score):
   목적: 두 특징 벡터의 "상대적 패턴" 비교
   
   등록 시: [100, 200, 300] → Z-score → [-1, 0, 1]
   로그인 시: [150, 300, 450] → Z-score → [-1, 0, 1]
   
   절대값은 다르지만 패턴(비율)은 동일!
   → 같은 사람으로 인식 ✓
```

### 5. 서명 생성 및 SHA-256

```
특징 벡터 (37개 실수)
    │
    │  가중치 적용
    │  ├─ 형태학적 × 1.5 (가장 중요)
    │  ├─ HRV × 1.0
    │  ├─ 주파수 × 0.8
    │  └─ 통계 × 0.7
    ▼
가중 벡터 [1.23, 45.6, 0.78, ...]
    │
    │  Min-Max 정규화
    ▼
정규화 벡터 [0.12, 0.89, 0.34, ...]  (0~1)
    │
    │  8비트 이산화: round(x × 255)
    ▼
이산 벡터 [31, 227, 87, ...]  (0~255 정수)
    │
    │  SHA-256 해시
    ▼
"a3f2b8c9d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0"
                    (64자 16진수, 256비트)
```

#### 가중치 적용의 의미

```
왜 가중치를 다르게 주는가?

형태학적 특징 (×1.5): 
- 심장의 물리적 구조 반영 (심장 크기, 전도 경로)
- 시간이 지나도 비교적 안정적
- 개인 고유성 가장 높음

HRV 특징 (×1.0):
- 자율신경계 상태 반영
- 스트레스, 운동 등에 영향받음
- 적당한 가중치

주파수 특징 (×0.8):
- 파형의 주파수 성분
- 노이즈 영향 받을 수 있음
- 약간 낮은 가중치

통계 특징 (×0.7):
- 일반적인 신호 특성
- 다른 특징들과 중복 가능
- 가장 낮은 가중치
```

#### 8비트 이산화 (Quantization)

```
왜 이산화하는가?

연속값:  0.12345678901234567890...
         (무한한 정밀도, 저장 비효율)
              ↓ 이산화
정수값:  31 (0~255 중 하나)
         (8비트 = 1바이트로 표현)

이산화 과정:
normalized = 0.12345...
discretized = round(0.12345 × 255) = round(31.48) = 31

37개 특징 × 1바이트 = 37바이트만 저장!
```

#### SHA-256 해시 함수

```
SHA-256 (Secure Hash Algorithm 256-bit)

입력: 임의 길이 데이터 (우리 경우: 37바이트 특징 벡터)
출력: 고정 256비트 (32바이트 = 64자 16진수)

┌─────────────────────────────────────────────────┐
│              SHA-256 내부 동작                   │
├─────────────────────────────────────────────────┤
│ 1. 패딩: 입력을 512비트 블록으로 나눔            │
│ 2. 초기화: 8개의 32비트 초기 해시값 설정         │
│ 3. 압축: 64라운드 반복 (XOR, AND, 회전, 덧셈)    │
│ 4. 출력: 8개 × 32비트 = 256비트 해시             │
└─────────────────────────────────────────────────┘
```

**SHA-256의 세 가지 핵심 특성**:

```
1️⃣ 단방향성 (One-way):
   입력 → 해시: O (계산 쉬움)
   해시 → 입력: X (계산적으로 불가능)
   
   해시값만으로 원본 ECG 복원 불가!
   → 생체 정보 보호

2️⃣ 충돌 저항성 (Collision Resistance):
   서로 다른 입력 x, y에 대해
   H(x) = H(y)인 경우 찾기 어려움
   
   2^128번 시도 필요 (천문학적 시간)
   → 다른 사람이 같은 해시 가질 확률 극히 낮음

3️⃣ 눈사태 효과 (Avalanche Effect):
   입력: [31, 227, 87, ...] → 해시: a3f2b8c9...
   입력: [32, 227, 87, ...] → 해시: 7d9e1f5a... (완전히 다름!)
   
   1비트만 바뀌어도 해시가 ~50% 달라짐
   → 미세한 차이도 감지 가능
```

#### 해시 vs 유사도 비교의 관계

```
⚠️ 중요: 해시만으로는 인증 불가!

문제:
- 같은 사람도 매번 측정값이 조금씩 다름
- 약간의 차이 → 눈사태 효과 → 완전히 다른 해시
- 해시 일치 = 거의 불가능

해결:
- 해시는 "데이터 무결성 확인"용으로만 사용
- 실제 인증은 "특징 벡터 유사도 비교"로 수행

저장: 해시 (압축, 보안) + 정규화 벡터 (비교용)
인증: 정규화 벡터끼리 유사도 계산
```

### 6. 하이브리드 유사도 계산

```python
하이브리드 유사도 = 0.7 × 코사인 유사도 + 0.3 × 유클리드 유사도
```

#### 코사인 유사도 (Cosine Similarity)

```
수식:
        A · B          Σ(Ai × Bi)
cos(θ) = ───────── = ─────────────────
        ‖A‖ × ‖B‖    √(ΣAi²) × √(ΣBi²)

범위: -1 ~ 1 (정규화 후 0 ~ 1)
의미: 두 벡터가 이루는 각도의 코사인

기하학적 해석:
        ↑ B
       /
      /θ  
     /───→ A
    
θ = 0°  → cos(θ) = 1  (같은 방향 = 같은 패턴)
θ = 90° → cos(θ) = 0  (직교 = 무관한 패턴)
θ = 180°→ cos(θ) = -1 (반대 방향 = 반대 패턴)
```

```
코사인 유사도의 특성: 크기 불변 (Scale Invariant)

벡터 A: [1, 2, 3]
벡터 B: [2, 4, 6] = 2 × A

cos(A, B) = (1×2 + 2×4 + 3×6) / (√14 × √56)
          = 28 / 28 = 1.0 (완벽히 동일!)

→ 크기(진폭)가 달라도 "비율(패턴)"이 같으면 1.0
→ ECG 측정 환경 차이로 인한 진폭 변동에 강건함
```

#### 유클리드 유사도 (Euclidean Similarity)

```
유클리드 거리:
d(A, B) = ‖A - B‖ = √(Σ(Ai - Bi)²)

유사도로 변환 (거리 → 유사도):
                1
similarity = ─────────────
             1 + d/scale

scale: 정규화 상수 (거리를 0~1로 조정)
```

```
왜 1/(1 + d) 형태인가?

거리가 0일 때:    similarity = 1/(1+0) = 1.0 (완벽히 일치)
거리가 1일 때:    similarity = 1/(1+1) = 0.5
거리가 무한대일 때: similarity → 0

이 변환의 장점:
- 항상 0~1 범위
- 거리가 멀수록 부드럽게 감소
- 극단적 거리에도 0으로 수렴
```

```
유클리드 유사도의 특성: 절대값 민감

벡터 A: [1, 2, 3]
벡터 B: [2, 4, 6]
벡터 C: [1, 2, 4]

d(A, B) = √((1-2)² + (2-4)² + (3-6)²) = √14 ≈ 3.74
d(A, C) = √((1-1)² + (2-2)² + (3-4)²) = √1 = 1.0

→ B는 A의 2배지만 거리가 멀다고 판단
→ C는 하나만 다르지만 더 가깝다고 판단

결론: 유클리드은 "실제 값의 차이"를 측정
```

#### 왜 하이브리드인가? (상호 보완)

```
시나리오 1: 같은 사람, 다른 측정 환경 (진폭 2배)

등록:    [1.0, 2.0, 3.0, ...]
로그인:  [2.0, 4.0, 6.0, ...]  (전극 접촉 좋음 → 신호 2배)

코사인 유사도: 1.0 ✓ (패턴 동일)
유클리드 유사도: ~0.3 ✗ (값 차이 큼)

→ 코사인 덕분에 인증 성공!
```

```
시나리오 2: 다른 사람, 비슷한 패턴

사용자 A: [1.0, 2.0, 3.0, ...]
사용자 B: [1.1, 2.2, 3.3, ...]  (비율은 비슷, 값은 다름)

코사인 유사도: 0.99 (패턴 거의 동일)
유클리드 유사도: 0.85 (값 차이 있음)

→ 유클리드이 차이를 잡아냄!
```

```
하이브리드의 균형:

하이브리드 = 0.7 × 코사인 + 0.3 × 유클리드

┌─────────────────────────────────────────────────────────────┐
│                 가중치 선택 근거 (0.7:0.3)                   │
├─────────────────────────────────────────────────────────────┤
│ 코사인 70%:                                                 │
│   - ECG 측정 환경 변화가 빈번함 (진폭 변동)                   │
│   - 패턴 유사성이 개인 식별의 핵심                           │
│   - 주요 판단 기준으로 사용                                  │
├─────────────────────────────────────────────────────────────┤
│ 유클리드 30%:                                               │
│   - 미세한 값 차이로 다른 사람 구분                          │
│   - 보조적 검증 수단                                        │
│   - 코사인 유사도가 비슷할 때 변별력 제공                    │
└─────────────────────────────────────────────────────────────┘
```

#### 인증 임계값 (Threshold = 80%)

```
유사도 → 판정:

유사도 ≥ 80%: 인증 성공 ✓ (같은 사람으로 판단)
유사도 < 80%: 인증 실패 ✗ (다른 사람으로 판단)

왜 80%인가?

실험적 관찰:
- 같은 사람: 평균 유사도 85~95%
- 다른 사람: 평균 유사도 40~70%

80%는 두 분포의 교차점 부근
→ False Accept Rate (오인식률) 최소화
→ False Reject Rate (오거부율) 최소화

┌────────────────────────────────────────┐
│          유사도 분포                    │
│                                        │
│  다른 사람              같은 사람       │
│    ▲                      ▲            │
│   /│\                    /│\           │
│  / │ \                  / │ \          │
│ /  │  \                / │  \          │
│────│───────────────────│────────▶      │
│   70%      80%        90%              │
│           (임계값)                      │
└────────────────────────────────────────┘
```

---

## 📱 앱 동작 상세

### 화면 구성
```
┌─────────────────────────────────────┐
│  ● 연결 상태 배지                    │
├─────────────────────────────────────┤
│  [📶 블루투스] [🌐 TCP 서버 연결]    │
├─────────────────────────────────────┤
│  사용자 ID: [_______________]       │
│  [등록] [로그인] [로그아웃]          │
├─────────────────────────────────────┤
│  [🧪 더미 데이터] [👥 사용자 목록]   │
├─────────────────────────────────────┤
│  ┌─────────────────────────────┐    │
│  │      ECG 실시간 그래프       │    │
│  │    ∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿      │    │
│  └─────────────────────────────┘    │
├─────────────────────────────────────┤
│  진행 상태: [████████░░] 80%        │
│  1600 / 2000 샘플                   │
├─────────────────────────────────────┤
│  결과: ✅ 로그인 성공 (유사도 92%)   │
└─────────────────────────────────────┘
```

### 등록/로그인 플로우
```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   버튼 클릭   │ ──▶ │  확인 팝업   │ ──▶ │  5초 안정화  │
│              │     │  "YES" 선택  │     │  카운트다운  │
└──────────────┘     └──────────────┘     └──────────────┘
                                                 │
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  결과 팝업   │ ◀── │  서버 처리   │ ◀── │ 6초 데이터   │
│ 성공/실패    │     │  + JSON 응답 │     │    수집      │
└──────────────┘     └──────────────┘     └──────────────┘
```

### 더미 데이터 생성 로직
```
심박수 변동: 60~85 BPM (서서히 변화)
베이스라인 드리프트: ±30 (천천히 흔들림)
RR 간격 변동: ±7.5% (부정맥 느낌)
진폭 변동: ±5% (비트마다 다름)
노이즈: 백색 + 60Hz 전원 + 근육 (현실감)
```

---

## 📁 프로젝트 구조 상세

```
ECG-SIGN-Digital-Signature-System/
│
├── Hardware/
│   ├── Arduino_Code/
│   │   └── main.ino              # 센서 읽기 + Bluetooth 전송
│   └── README.md                 # 하드웨어 설정 가이드
│
├── Software/
│   ├── Android_App/
│   │   └── app/src/main/
│   │       ├── java/.../MainActivity.java   # 메인 로직
│   │       └── res/layout/activity_main.xml # UI 레이아웃
│   │
│   └── Signal_Processing/
│       ├── ecg_server.py         # TCP 서버 메인
│       ├── requirements.txt      # Python 의존성
│       ├── user_data/
│       │   └── users.json        # 등록된 사용자 데이터
│       └── ecg_processor/
│           ├── __init__.py
│           ├── preprocessing.py      # 1. 전처리 (필터링)
│           ├── r_peak_detector.py    # 2. R-peak (Pan-Tompkins)
│           ├── beat_processor.py     # 3. 비트 처리
│           ├── feature_extractor.py  # 4. 특징 추출
│           ├── signature_generator.py # 5. 서명 생성
│           ├── pipeline.py           # 통합 파이프라인
│           └── auth_manager.py       # 사용자 인증
│
└── Docs/
    ├── README.md                 # 발표 자료
    ├── TECHNICAL_DETAILS.md      # 기술 상세 문서
    └── QUICK_OVERVIEW.md         # 이 문서
```

---

## ✅ 발표 포인트 정리

### Q&A 예상 질문과 답변

| 질문 | 답변 |
|------|------|
| 왜 ECG인가? | 살아있는 사람만 측정 가능, 위조 불가, 지속 인증 가능 |
| Pan-Tompkins가 뭔가요? | 1985년 발표된 실시간 QRS 검출 표준 알고리즘 |
| 왜 특징을 이렇게 많이 추출? | 형태+시간+주파수+통계 조합으로 개인 고유성 극대화 |
| 정확도는? | 유사도 80% 이상 시 인증 성공, 하이브리드 방식으로 정확도 향상 |
| 실시간 가능? | 6초 데이터면 처리 완료, 웨어러블 기기로 확장 가능 |
| 보안은? | SHA-256 해시로 원본 복원 불가, 유사도 비교만 수행 |

### 핵심 메시지 3가지
1. **형태학적 특징 기반**: 단순 심박수가 아닌 파형의 **모양**을 분석
2. **표준 알고리즘 적용**: Pan-Tompkins, Butterworth, SHA-256
3. **하이브리드 인증**: 코사인(패턴) + 유클리드(값) 조합으로 정확도 향상

---

## 🚀 한 문장 정리

> "ECG 파형에서 **Pan-Tompkins**로 심박을 찾고, **30개 이상의 형태학적·시간·주파수·통계 특징**을 추출해 **SHA-256 해시**로 변환한 뒤, **하이브리드 유사도(코사인 70% + 유클리드 30%)**로 본인 여부를 판단하는 **2차 인증 시스템**"

---

## 📈 성능 지표

| 항목 | 값 | 비고 |
|------|-----|------|
| 샘플링 레이트 | 500 Hz | 2ms 간격 |
| 수집 시간 | 6초 | 3000 샘플 |
| 처리 시간 | < 1초 | 파이프라인 전체 |
| 특징 수 | 37개+ | 4개 도메인 |
| 인증 임계값 | 80% | 하이브리드 유사도 |
| 서명 길이 | 64자 | SHA-256 해시 |
